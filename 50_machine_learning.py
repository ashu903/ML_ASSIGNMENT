# -*- coding: utf-8 -*-
"""50.Machine_Learning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lfQ1vrVyDVzZgy5kq93lxR-2tkjpZloY
"""

# 50.Machine Learning

# Q What is the difference between Series & Dataframes.
# Ans>> A Series and a DataFrame are fundamental data structures in the pandas library, used for data manipulation and analysis. Here are the key differences between them:
# Series: A Series is a one-dimensional array-like structure that can hold elements of any data type. It is similar to a single column in a spreadsheet or a single array in programming.
# DataFrame: A DataFrame is a two-dimensional, tabular data structure with labeled axes (rows and columns). It is akin to an entire table or a spreadsheet, with each column potentially holding data of different types.
import pandas as pd
# Creating a Series
s = pd.Series([10, 20, 30, 40], index=['a', 'b', 'c', 'd'])
print(s)
# Creating a DataFrame
df = pd.DataFrame({
    'Name': ['Alice', 'Bob', 'Charlie'],
    'Age': [25, 30, 35],
    'Salary': [50000, 60000, 70000]
})
print(df)

# Q Difference between loc and iloc.
# ANS>> In pandas, .loc and .iloc are methods used for data selection and manipulation in DataFrames. They differ primarily in how they refer to data within the DataFrame.
# loc:
# Label-based Indexing: .loc is used to access a group of rows and columns by their labels or a boolean array. It requires that you specify the exact row and column labels.
# Inclusive Slicing: When using slices, .loc includes both the start and end labels.
# Flexible Indexing: .loc allows for mixed indexing (using both row and column labels) and supports boolean indexing.
import pandas as pd

# Sample DataFrame
df = pd.DataFrame({
    'A': [1, 2, 3],
    'B': [4, 5, 6],
    'C': [7, 8, 9]
}, index=['row1', 'row2', 'row3'])

# Accessing data using .loc
print(df.loc['row1', 'A'])       # Accessing a single element
print(df.loc['row1':'row2', ['A', 'C']])  # Accessing a subset of rows and columns

# iloc:
# Integer-location Based Indexing: .iloc is used to access a group of rows and columns by their integer positions, which are similar to the positions used in Python lists.
# Exclusive Slicing: When using slices, .iloc excludes the end index, which is typical of Python's slicing behavior.
# Position-based Indexing: .iloc does not consider the labels of the rows and columns; it uses only their numerical positions.
import pandas as pd

# Sample DataFrame
df = pd.DataFrame({
    'A': [1, 2, 3],
    'B': [4, 5, 6],
    'C': [7, 8, 9]
})

# Accessing data using .iloc
print(df.iloc[0, 0])      # Accessing a single element
print(df.iloc[0:2, [0, 2]])  # Accessing a subset of rows and columns

!pip install pandas sqlalchemy pymysql

import mysql.connector
mydb = mysql.connector.connect(
  host="localhost",
  user="abc",
  password="password"
)
mycursor = mydb.cursor()
mycursor.execute("select * Trvel_Plnner")
for i in mycursor.fetchall() :
    print(i)


mydb.close()
import mysql.connector
mydb = mysql.connector.connect(
  host="localhost",
  user="abc",
  password="password"
)
mycursor = mydb.cursor()
mycursor.execute("CREATE DATABASE if not exists Trvel_Plnner ")
mydb.close()



import mysql.connector
mydb = mysql.connector.connect(
  host="localhost",
  user="abc",
  password="password"
)
mycursor = mydb.cursor()
mycursor.execute('CREATE TABLE bookings(user_id INT, flight_id INT,hotel_id INT, activity_id INT,booking_deate, DATE)')
mydb.close()


import mysql.connector
mydb = mysql.connector.connect(
  host="localhost",
  user="abc",
  password="password"
)
mycursor = mydb.cursor()
mycursor.execute("insert into bookings values(12345 ,'9999' , 666  , '28-07-24' )")
mydb.commit()
mydb.close()